/*
=============================================================
  CYBER HAWK - ESP32-CAM Controller v4.0
  Compatible with CYBER HAWK Genesis Edition HTML Dashboard
=============================================================

  ENDPOINTS MATCHED TO HTML:
  - /stream                                  ← MJPEG live stream
  - /status                                  ← connection check (HEAD)
  - /joystick?roll=&pitch=&yaw=&throttle=    ← forwarded to WROOM via UART
  - /command?cmd=                            ← forwarded to WROOM via UART

  STREAM SETTINGS:
  - Resolution : CIF (400x296) — closest to requested 480x240
  - FPS        : ~15 (controlled by jpeg_quality + fb_count)
  - Format     : MJPEG

  WIRING (ESP32-CAM to ESP32-WROOM):
  - CAM TX (GPIO1)  → WROOM RX (GPIO16)
  - CAM RX (GPIO3)  → WROOM TX (GPIO17)
  - GND             → GND

  NOTE: CYBER_HAWK_CAM is the AP the HTML connects to.
        CAM forwards all joystick/command data to WROOM via UART.
=============================================================
*/

#include "esp_camera.h"
#include "esp_http_server.h"
#include <WiFi.h>
#include <WebServer.h>

// ── UART to WROOM ───────────────────────────────────────
#define RXD2 3
#define TXD2 1

// ── WiFi ────────────────────────────────────────────────
// HTML connects to THIS network (192.168.4.1)
const char* ssid     = "CYBER_HAWK";
const char* password = "12345678";

WebServer server(80);

// ── Camera Pin Map (AI-Thinker ESP32-CAM) ───────────────
#define PWDN_GPIO_NUM     32
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM      0
#define SIOD_GPIO_NUM     26
#define SIOC_GPIO_NUM     27
#define Y9_GPIO_NUM       35
#define Y8_GPIO_NUM       34
#define Y7_GPIO_NUM       39
#define Y6_GPIO_NUM       36
#define Y5_GPIO_NUM       21
#define Y4_GPIO_NUM       19
#define Y3_GPIO_NUM       18
#define Y2_GPIO_NUM        5
#define VSYNC_GPIO_NUM    25
#define HREF_GPIO_NUM     23
#define PCLK_GPIO_NUM     22

// ── Stream handle ───────────────────────────────────────
httpd_handle_t streamHttpd = NULL;

// ── MJPEG Stream Handler ────────────────────────────────
#define PART_BOUNDARY "123456789000000000000987654321"
static const char* STREAM_CONTENT_TYPE =
    "multipart/x-mixed-replace;boundary=" PART_BOUNDARY;
static const char* STREAM_BOUNDARY = "\r\n--" PART_BOUNDARY "\r\n";
static const char* STREAM_PART =
    "Content-Type: image/jpeg\r\nContent-Length: %u\r\n\r\n";

esp_err_t streamHandler(httpd_req_t* req) {
  camera_fb_t* fb        = NULL;
  esp_err_t    res       = ESP_OK;
  size_t       _jpg_buf_len = 0;
  uint8_t*     _jpg_buf     = NULL;
  char         part_buf[64];

  res = httpd_resp_set_type(req, STREAM_CONTENT_TYPE);
  if (res != ESP_OK) return res;

  // CORS header so browser HTML file can access stream
  httpd_resp_set_hdr(req, "Access-Control-Allow-Origin", "*");

  while (true) {
    fb = esp_camera_fb_get();
    if (!fb) {
      res = ESP_FAIL;
      break;
    }

    if (fb->format != PIXFORMAT_JPEG) {
      bool jpeg_converted = frame2jpg(fb, 80, &_jpg_buf, &_jpg_buf_len);
      esp_camera_fb_return(fb);
      fb = NULL;
      if (!jpeg_converted) { res = ESP_FAIL; break; }
    } else {
      _jpg_buf_len = fb->len;
      _jpg_buf     = fb->buf;
    }

    // Write boundary
    res = httpd_resp_send_chunk(req, STREAM_BOUNDARY, strlen(STREAM_BOUNDARY));
    if (res != ESP_OK) break;

    // Write part header
    size_t hlen = snprintf(part_buf, 64, STREAM_PART, _jpg_buf_len);
    res = httpd_resp_send_chunk(req, part_buf, hlen);
    if (res != ESP_OK) break;

    // Write JPEG data
    res = httpd_resp_send_chunk(req, (const char*)_jpg_buf, _jpg_buf_len);

    if (fb) { esp_camera_fb_return(fb); fb = NULL; }
    else    { free(_jpg_buf); }

    if (res != ESP_OK) break;
  }

  return res;
}

// ── Start MJPEG Stream Server on port 80 /stream ────────
void startStreamServer() {
  httpd_config_t config = HTTPD_DEFAULT_CONFIG();
  config.server_port = 81;   // Stream on port 81 to avoid conflict

  httpd_uri_t streamUri = {
    .uri      = "/stream",
    .method   = HTTP_GET,
    .handler  = streamHandler,
    .user_ctx = NULL
  };

  if (httpd_start(&streamHttpd, &config) == ESP_OK) {
    httpd_register_uri_handler(streamHttpd, &streamUri);
    Serial.println("Stream started at http://192.168.4.1:81/stream");
  }
}

// ── Camera Init ─────────────────────────────────────────
void startCamera() {
  camera_config_t config;
  config.ledc_channel  = LEDC_CHANNEL_0;
  config.ledc_timer    = LEDC_TIMER_0;
  config.pin_d0        = Y2_GPIO_NUM;
  config.pin_d1        = Y3_GPIO_NUM;
  config.pin_d2        = Y4_GPIO_NUM;
  config.pin_d3        = Y5_GPIO_NUM;
  config.pin_d4        = Y6_GPIO_NUM;
  config.pin_d5        = Y7_GPIO_NUM;
  config.pin_d6        = Y8_GPIO_NUM;
  config.pin_d7        = Y9_GPIO_NUM;
  config.pin_xclk      = XCLK_GPIO_NUM;
  config.pin_pclk      = PCLK_GPIO_NUM;
  config.pin_vsync     = VSYNC_GPIO_NUM;
  config.pin_href      = HREF_GPIO_NUM;
  config.pin_sscb_sda  = SIOD_GPIO_NUM;
  config.pin_sscb_scl  = SIOC_GPIO_NUM;
  config.pin_pwdn      = PWDN_GPIO_NUM;
  config.pin_reset     = RESET_GPIO_NUM;
  config.xclk_freq_hz  = 20000000;
  config.pixel_format  = PIXFORMAT_JPEG;

  // CIF = 400x296 — closest available to 480x240
  // QVGA = 320x240 — alternative if CIF is too heavy
  config.frame_size    = FRAMESIZE_CIF;
  config.jpeg_quality  = 15;   // 0=best, 63=worst — 15 gives ~15fps on CIF
  config.fb_count      = 2;

  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed: 0x%x\n", err);
    return;
  }

  // Fine-tune sensor for better image
  sensor_t* s = esp_camera_sensor_get();
  if (s) {
    s->set_brightness(s, 0);
    s->set_contrast(s, 0);
    s->set_saturation(s, 0);
    s->set_whitebal(s, 1);
    s->set_awb_gain(s, 1);
    s->set_exposure_ctrl(s, 1);
    s->set_aec2(s, 1);
  }

  Serial.println("Camera ready");
}

// ── CORS Headers ────────────────────────────────────────
void addCORS() {
  server.sendHeader("Access-Control-Allow-Origin",  "*");
  server.sendHeader("Access-Control-Allow-Methods", "GET, HEAD, OPTIONS");
  server.sendHeader("Access-Control-Allow-Headers", "*");
}

// ── /status ─────────────────────────────────────────────
void handleStatus() {
  addCORS();
  server.send(200, "text/plain", "OK");
}

// ── /joystick ───────────────────────────────────────────
// HTML sends: roll, pitch (left stick) or yaw, throttle (right stick)
// Forward to WROOM via UART in format: J:throttle,pitch,roll,yaw
void handleJoystick() {
  addCORS();

  float roll     = server.hasArg("roll")     ? server.arg("roll").toFloat()     : 0;
  float pitch    = server.hasArg("pitch")    ? server.arg("pitch").toFloat()    : 0;
  float yaw      = server.hasArg("yaw")      ? server.arg("yaw").toFloat()      : 0;
  float throttle = server.hasArg("throttle") ? server.arg("throttle").toFloat() : 0;

  // Scale -1.0..1.0 to integer range for WROOM
  int t = (int)(throttle * 255);
  int p = (int)(pitch    * 100);
  int r = (int)(roll     * 100);
  int y = (int)(yaw      * 100);

  // Send to WROOM
  String data = "J:" + String(t) + "," + String(p) + "," +
                String(r) + "," + String(y);
  Serial2.println(data);

  server.send(200, "text/plain", "OK");
}

// ── /command ────────────────────────────────────────────
// Forward all commands to WROOM via UART
void handleCommand() {
  addCORS();
  String cmd = server.arg("cmd");

  // Forward to WROOM as-is
  Serial2.println("CMD:" + cmd);

  Serial.println("CMD forwarded: " + cmd);
  server.send(200, "text/plain", "CMD_OK");
}

// ── Setup ───────────────────────────────────────────────
void setup() {
  Serial.begin(115200);

  // UART to WROOM Flight Controller
  Serial2.begin(115200, SERIAL_8N1, RXD2, TXD2);

  // Start WiFi AP — HTML connects here
  WiFi.softAP(ssid, password);
  Serial.print("CAM AP IP: ");
  Serial.println(WiFi.softAPIP());

  // Init camera
  startCamera();

  // Start MJPEG stream server on port 81
  startStreamServer();

  // Register command/status endpoints on port 80
  server.on("/status",   HTTP_GET,  handleStatus);
  server.on("/status",   HTTP_HEAD, handleStatus);
  server.on("/joystick", HTTP_GET,  handleJoystick);
  server.on("/command",  HTTP_GET,  handleCommand);

  server.onNotFound([](){
    if (server.method() == HTTP_OPTIONS) {
      addCORS();
      server.send(204);
    } else {
      server.send(404, "text/plain", "Not Found");
    }
  });

  server.begin();
  Serial.println("CYBER HAWK CAM Ready");
  Serial.println("Stream: http://192.168.4.1:81/stream");
}

// ── Loop ────────────────────────────────────────────────
void loop() {
  server.handleClient();
}
